\section{Experimental Setup}

\subsection{Environment Configuration}

In the experimental setup, the environment configuration entails the setup of both the Kubernetes cluster and the HashiCorp Vault instance.

For the Kubernetes cluster, a standard setup using a cloud provider or a local development environment, such as Minikube or Kind, can be used. The cluster should be configured with sufficient resources to deploy the application pods and accommodate any additional components required for integration with Vault.

The HashiCorp Vault instance should be deployed and configured to serve as the central secrets management platform. This includes configuring authentication methods, such as tokens or Kubernetes service accounts, enabling the necessary secrets engines (e.g., Key/Value, AWS, Database), and defining access policies to control who can access which secrets.

Additionally, environment variables should be set up within the Kubernetes cluster to provide necessary configuration parameters to the script, such as \texttt{VAULT\_ENABLE}, \texttt{VAULT\_TOKEN}, \texttt{VAULT\_SERVICE\_HOST}, and \texttt{VAULT\_SERVICE\_PORT}. These variables should be securely managed and protected to prevent unauthorized access.

\subsection{Implementation Details}

The implementation details section provides insights into how the script provided in the previous section is integrated into the Kubernetes deployment and how it interacts with HashiCorp Vault.

Firstly, the script should be packaged along with the application container image or as a ConfigMap in Kubernetes. This ensures that it is available within the container environment and can be executed as part of the pod lifecycle.

During pod initialization, Kubernetes mounts the script and executes it as a liveness probe. The script then communicates with HashiCorp Vault using the specified address and token to fetch secrets as needed.

The script utilizes standard Unix commands, such as \texttt{curl} and \texttt{jq}, to interact with the Vault API and parse the JSON responses. It also handles various HTTP status codes returned by the API calls to handle different scenarios, such as initializing a new secret store or updating environment variables.

Upon detecting changes in the retrieved secrets, the script exports them as environment variables within the pod, ensuring that the application has access to the latest configuration. If changes are detected, the script exits with a non-zero status code, triggering Kubernetes to restart the pod and apply the updated environment variables.

Overall, the implementation details highlight the seamless integration of the script with Kubernetes and its interaction with HashiCorp Vault to ensure the continuous availability and integrity of secrets within the containerized environment.
